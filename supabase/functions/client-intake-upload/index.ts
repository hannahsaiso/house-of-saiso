 import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
 import { createClient } from "https://esm.sh/@supabase/supabase-js@2.93.3";
 
 const corsHeaders = {
   "Access-Control-Allow-Origin": "*",
   "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type, x-supabase-client-platform, x-supabase-client-platform-version, x-supabase-client-runtime, x-supabase-client-runtime-version",
 };
 
 interface IntakeRequest {
   token: string;
   action: "validate" | "upload" | "complete";
   file_name?: string;
   file_data?: string; // base64
   file_type?: string;
   visual_anchors?: string[];
 }

// Allowed file extensions (server-side validation)
const ALLOWED_EXTENSIONS = [
  '.jpg', '.jpeg', '.png', '.svg', '.webp', '.gif',
  '.pdf', '.ai', '.eps',
  '.zip',
  '.mov', '.mp4',
  '.otf', '.ttf', '.woff', '.woff2'
];

const BLOCKED_EXTENSIONS = [
  '.exe', '.js', '.jsx', '.ts', '.tsx', '.bat', '.cmd', '.sh', '.php', '.py', '.rb',
  '.dll', '.com', '.msi', '.scr', '.vbs', '.ps1', '.jar', '.class'
];

// Validate file name for security
function isValidFileName(fileName: string): boolean {
  const extension = '.' + fileName.split('.').pop()?.toLowerCase();
  
  // Block dangerous extensions
  if (BLOCKED_EXTENSIONS.includes(extension)) {
    console.log(`Blocked dangerous file: ${fileName}`);
    return false;
  }
  
  // Check if extension is allowed
  if (!ALLOWED_EXTENSIONS.includes(extension)) {
    console.log(`File extension not allowed: ${fileName}`);
    return false;
  }
  
  return true;
}

// Sanitize text input to prevent XSS
function sanitizeInput(input: string): string {
  return input
    .replace(/[<>]/g, '') // Remove angle brackets
    .replace(/javascript:/gi, '') // Remove javascript: protocol
    .replace(/on\w+=/gi, '') // Remove event handlers
    .replace(/data:/gi, '') // Remove data: protocol  
    .trim();
}

// Generate a simple text-based PDF content
function generateIntakeSummaryPDF(
  clientName: string,
  projectTitle: string,
  visualAnchors: string[],
  filesCount: number
): string {
  const now = new Date().toLocaleDateString('en-US', { 
    year: 'numeric', 
    month: 'long', 
    day: 'numeric' 
  });
  
  // Create a simple PDF structure
  const objects: string[] = [];
  let objectNumber = 0;
  
  const addObject = (content: string): number => {
    objectNumber++;
    objects.push(`${objectNumber} 0 obj\n${content}\nendobj\n`);
    return objectNumber;
  };
  
  // Catalog
  addObject('<< /Type /Catalog /Pages 2 0 R >>');
  
  // Pages
  addObject('<< /Type /Pages /Kids [3 0 R] /Count 1 >>');
  
  // Page
  addObject('<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 4 0 R /Resources << /Font << /F1 5 0 R /F2 6 0 R >> >> >>');
  
  // Content stream
  const lines: string[] = [];
  let y = 720;
  const lineHeight = 18;
  const headerHeight = 28;
  
  const addLine = (text: string, fontSize: number = 12, isHeader: boolean = false) => {
    const escapedText = text.replace(/\\/g, '\\\\').replace(/\(/g, '\\(').replace(/\)/g, '\\)');
    const font = isHeader ? '/F2' : '/F1';
    lines.push(`BT ${font} ${fontSize} Tf 72 ${y} Td (${escapedText}) Tj ET`);
    y -= isHeader ? headerHeight : lineHeight;
  };
  
  // Title
  addLine('INTAKE SUMMARY', 24, true);
  addLine(`${projectTitle}`, 18, true);
  y -= 10;
  
  // Meta info
  addLine(`Client: ${clientName}`, 12);
  addLine(`Generated: ${now}`, 12);
  y -= 20;
  
  // Divider line
  lines.push(`q 0.8 0.8 0.8 RG 72 ${y + 10} m 540 ${y + 10} l S Q`);
  y -= 20;
  
  // Assets Section
  addLine('BRAND ASSETS', 14, true);
  addLine(`${filesCount} file${filesCount !== 1 ? 's' : ''} uploaded to project folder`, 12);
  y -= 20;
  
  // Visual Anchors Section
  if (visualAnchors.length > 0) {
    addLine('VISUAL ANCHORS & REFERENCES', 14, true);
    visualAnchors.forEach((anchor, index) => {
      if (y > 100) {
        addLine(`${index + 1}. ${anchor.substring(0, 70)}${anchor.length > 70 ? '...' : ''}`, 11);
      }
    });
    y -= 20;
  }
  
  // Footer note
  y = 100;
  lines.push(`q 0.8 0.8 0.8 RG 72 ${y + 10} m 540 ${y + 10} l S Q`);
  y -= 10;
  addLine('This document was automatically generated by House of Saiso.', 10);
  addLine('For questions, please contact your project lead.', 10);
  
  const contentStream = lines.join('\n');
  addObject(`<< /Length ${contentStream.length} >>\nstream\n${contentStream}\nendstream`);
  
  // Fonts (Helvetica for body, Helvetica-Bold for headers)
  addObject('<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica >>');
  addObject('<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica-Bold >>');
  
  // Build the PDF
  let pdf = '%PDF-1.4\n';
  let xrefPositions: number[] = [];
  
  objects.forEach((obj) => {
    xrefPositions.push(pdf.length);
    pdf += obj;
  });
  
  const xrefStart = pdf.length;
  pdf += 'xref\n';
  pdf += `0 ${objectNumber + 1}\n`;
  pdf += '0000000000 65535 f \n';
  xrefPositions.forEach((pos) => {
    pdf += `${pos.toString().padStart(10, '0')} 00000 n \n`;
  });
  
  pdf += 'trailer\n';
  pdf += `<< /Size ${objectNumber + 1} /Root 1 0 R >>\n`;
  pdf += 'startxref\n';
  pdf += `${xrefStart}\n`;
  pdf += '%%EOF';
  
  return pdf;
}

// Send email via Gmail API
async function sendConfirmationEmail(
  accessToken: string,
  clientEmail: string,
  clientName: string,
  pdfContent: string
): Promise<boolean> {
  try {
    const subject = `The Foundation is Set: ${clientName} x House of Saiso`;
    
    const emailBody = `${clientName},

Thank you for sharing your vision with us. We have successfully received your project brief and brand assets.

At House of Saiso, we believe the strongest creative work is built on a deep strategic foundation. My team and I are currently diving into your "Brand DNA" to synthesise your goals, visual anchors, and competitive landscape into a clear path forward.

What Happens Next:

We are reviewing your intake canvas as a priority. We will be in touch shortly to discuss the creative direction and the next phase of our journey together.

For your records, I have attached a PDF summary of your intake session to this email.

We're diving in now.

Hannah
House of Saiso`;

    // Encode PDF to base64
    const pdfBase64 = btoa(pdfContent);
    
    // Create MIME message with attachment
    const boundary = "intake_email_boundary_" + Date.now();
    
    const mimeMessage = [
      `From: me`,
      `To: ${clientEmail}`,
      `Subject: ${subject}`,
      `MIME-Version: 1.0`,
      `Content-Type: multipart/mixed; boundary="${boundary}"`,
      ``,
      `--${boundary}`,
      `Content-Type: text/plain; charset="UTF-8"`,
      `Content-Transfer-Encoding: 7bit`,
      ``,
      emailBody,
      ``,
      `--${boundary}`,
      `Content-Type: application/pdf; name="Intake_Summary.pdf"`,
      `Content-Disposition: attachment; filename="Intake_Summary.pdf"`,
      `Content-Transfer-Encoding: base64`,
      ``,
      pdfBase64,
      ``,
      `--${boundary}--`,
    ].join('\r\n');
    
    // Base64url encode the message
    const base64url = btoa(mimeMessage)
      .replace(/\+/g, '-')
      .replace(/\//g, '_')
      .replace(/=+$/, '');
    
    const response = await fetch(
      'https://gmail.googleapis.com/gmail/v1/users/me/messages/send',
      {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ raw: base64url }),
      }
    );
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error('Failed to send email:', errorText);
      return false;
    }
    
    console.log('Confirmation email sent successfully');
    return true;
  } catch (error) {
    console.error('Error sending email:', error);
    return false;
  }
}
 
 async function uploadFileToDrive(
   accessToken: string,
   folderId: string,
   fileName: string,
   fileData: Uint8Array,
   mimeType: string
 ): Promise<{ id: string; name: string } | null> {
   try {
     const metadata = {
       name: fileName,
       parents: [folderId],
     };
 
     const boundary = "intake_upload_boundary";
     const delimiter = `\r\n--${boundary}\r\n`;
     const closeDelimiter = `\r\n--${boundary}--`;
 
     const metadataPart = 
       delimiter +
       "Content-Type: application/json; charset=UTF-8\r\n\r\n" +
       JSON.stringify(metadata);
 
     const filePart = 
       delimiter +
       `Content-Type: ${mimeType}\r\n` +
       "Content-Transfer-Encoding: base64\r\n\r\n";
 
     // Convert file data to base64
     const base64Data = btoa(String.fromCharCode(...fileData));
 
     const multipartBody = metadataPart + filePart + base64Data + closeDelimiter;
 
     const response = await fetch(
       "https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart",
       {
         method: "POST",
         headers: {
           Authorization: `Bearer ${accessToken}`,
           "Content-Type": `multipart/related; boundary=${boundary}`,
         },
         body: multipartBody,
       }
     );
 
     if (!response.ok) {
       console.error("Failed to upload file:", await response.text());
       return null;
     }
 
     return await response.json();
   } catch (error) {
     console.error("Error uploading file:", error);
     return null;
   }
 }
 
 async function createDriveFolder(
   accessToken: string,
   name: string,
   parentId?: string
 ): Promise<{ id: string; name: string } | null> {
   try {
     const metadata: Record<string, unknown> = {
       name,
       mimeType: "application/vnd.google-apps.folder",
     };
     
     if (parentId) {
       metadata.parents = [parentId];
     }
 
     const response = await fetch("https://www.googleapis.com/drive/v3/files", {
       method: "POST",
       headers: {
         Authorization: `Bearer ${accessToken}`,
         "Content-Type": "application/json",
       },
       body: JSON.stringify(metadata),
     });
 
     if (!response.ok) {
       console.error("Failed to create folder:", await response.text());
       return null;
     }
 
     return await response.json();
   } catch (error) {
     console.error("Error creating folder:", error);
     return null;
   }
 }
 
 serve(async (req) => {
   if (req.method === "OPTIONS") {
     return new Response("ok", { headers: corsHeaders });
   }
 
   try {
     const supabaseUrl = Deno.env.get("SUPABASE_URL")!;
     const supabaseKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;
     const supabase = createClient(supabaseUrl, supabaseKey);
 
     const body: IntakeRequest = await req.json();
     const { token, action } = body;
 
      // Validate token format (must be 64 character hex string)
      if (!token || typeof token !== 'string' || !/^[a-f0-9]{64}$/i.test(token)) {
        // Return 404 to prevent token enumeration
        return new Response(
          JSON.stringify({ error: "not_found" }),
          { status: 404, headers: { ...corsHeaders, "Content-Type": "application/json" } }
        );
      }

     // Validate token
     const { data: intakeToken, error: tokenError } = await supabase
       .from("client_intake_tokens")
       .select(`
         *,
          projects!inner(id, title, client_id, intake_folder_id, created_by, onboarding_status, clients(name, company, email))
       `)
       .eq("token", token)
       .single();
 
     if (tokenError || !intakeToken) {
        // Return 404 to prevent token enumeration attacks
       return new Response(
          JSON.stringify({ error: "not_found" }),
          { status: 404, headers: { ...corsHeaders, "Content-Type": "application/json" } }
       );
     }
 
     const project = intakeToken.projects;
     const clientName = project.clients?.company || project.clients?.name || "Client";
 
     // Handle validation request
     if (action === "validate") {
        // Check if already completed - show success page but don't allow new submissions
        if (!intakeToken.is_active || intakeToken.completed_at || project.onboarding_status === "completed") {
          return new Response(
            JSON.stringify({
              already_completed: true,
              project_title: project.title,
              client_name: clientName,
            }),
            { headers: { ...corsHeaders, "Content-Type": "application/json" } }
          );
        }
        
        // Check expiration
        if (intakeToken.expires_at && new Date(intakeToken.expires_at) < new Date()) {
          return new Response(
            JSON.stringify({ error: "This access link has expired" }),
            { status: 403, headers: { ...corsHeaders, "Content-Type": "application/json" } }
          );
        }
        
       return new Response(
         JSON.stringify({
           valid: true,
           project_title: project.title,
           client_name: clientName,
           uploaded_files_count: intakeToken.uploaded_files_count || 0,
           visual_anchors: intakeToken.visual_anchors || [],
         }),
         { headers: { ...corsHeaders, "Content-Type": "application/json" } }
       );
     }
 
      // For upload and complete actions, verify token is still active
      if (!intakeToken.is_active || intakeToken.completed_at) {
        return new Response(
          JSON.stringify({ error: "This submission has already been completed" }),
          { status: 403, headers: { ...corsHeaders, "Content-Type": "application/json" } }
        );
      }
      
      // Check expiration for non-validate actions
      if (intakeToken.expires_at && new Date(intakeToken.expires_at) < new Date()) {
        return new Response(
          JSON.stringify({ error: "This access link has expired" }),
          { status: 403, headers: { ...corsHeaders, "Content-Type": "application/json" } }
        );
      }

     // Get admin's Google OAuth token
     const { data: tokenData, error: oauthError } = await supabase
       .from("google_oauth_tokens")
       .select("access_token")
       .eq("user_id", project.created_by)
       .single();
 
     if (oauthError || !tokenData?.access_token) {
       console.error("No OAuth token for project creator:", oauthError);
       return new Response(
         JSON.stringify({ error: "File upload not configured. Please contact support." }),
         { status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" } }
       );
     }
 
     const accessToken = tokenData.access_token;
 
     // Ensure intake folder exists
     let folderId = project.intake_folder_id;
     
     if (!folderId) {
       // Create the intake folder structure
       const safeClientName = clientName.replace(/[^a-zA-Z0-9\s]/g, "").trim();
       const intakeFolder = await createDriveFolder(
         accessToken, 
         `${safeClientName} / 00_INTAKE_&_ASSETS`
       );
       
       if (intakeFolder) {
         folderId = intakeFolder.id;
         await supabase
           .from("projects")
           .update({ intake_folder_id: folderId })
           .eq("id", project.id);
       } else {
         return new Response(
           JSON.stringify({ error: "Failed to create upload folder" }),
           { status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" } }
         );
       }
     }
 
     // Handle file upload
     if (action === "upload") {
       const { file_name, file_data, file_type } = body;
       
       if (!file_name || !file_data || !file_type) {
         return new Response(
           JSON.stringify({ error: "Missing file data" }),
           { status: 400, headers: { ...corsHeaders, "Content-Type": "application/json" } }
         );
       }
 
        // Server-side file type validation
        if (!isValidFileName(file_name)) {
          return new Response(
            JSON.stringify({ error: "File type not allowed" }),
            { status: 400, headers: { ...corsHeaders, "Content-Type": "application/json" } }
          );
        }

       // Decode base64 file data
       const binaryString = atob(file_data);
       const bytes = new Uint8Array(binaryString.length);
       for (let i = 0; i < binaryString.length; i++) {
         bytes[i] = binaryString.charCodeAt(i);
       }
 
       const uploadedFile = await uploadFileToDrive(
         accessToken,
         folderId,
         file_name,
         bytes,
         file_type
       );
 
       if (!uploadedFile) {
         return new Response(
           JSON.stringify({ error: "Failed to upload file" }),
           { status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" } }
         );
       }
 
       // Update file count
       const newCount = (intakeToken.uploaded_files_count || 0) + 1;
       await supabase
         .from("client_intake_tokens")
         .update({ uploaded_files_count: newCount })
         .eq("id", intakeToken.id);
 
       console.log(`File uploaded: ${file_name} to folder ${folderId}`);
 
       return new Response(
         JSON.stringify({
           success: true,
           file_id: uploadedFile.id,
           file_name: uploadedFile.name,
           uploaded_count: newCount,
         }),
         { headers: { ...corsHeaders, "Content-Type": "application/json" } }
       );
     }
 
     // Handle completion
     if (action === "complete") {
       const { visual_anchors } = body;
 
        // Sanitize all visual anchors
        const sanitizedAnchors = (visual_anchors || []).map((anchor: string) => sanitizeInput(anchor));

       // Update token as completed and deactivate
       await supabase
         .from("client_intake_tokens")
         .update({
           is_active: false,
           completed_at: new Date().toISOString(),
            visual_anchors: sanitizedAnchors,
         })
         .eq("id", intakeToken.id);
 
       // Update project onboarding status
       await supabase
         .from("projects")
         .update({ onboarding_status: "completed" })
         .eq("id", project.id);
 
       // Update knowledge vault with visual anchors if they exist
        if (sanitizedAnchors && sanitizedAnchors.length > 0) {
         const { data: vault } = await supabase
           .from("project_knowledge_vault")
           .select("id")
           .eq("project_id", project.id)
           .single();
 
         if (vault) {
           // Add visual anchors as primary references
           const existingCharter = await supabase
             .from("project_knowledge_vault")
             .select("project_charter")
             .eq("id", vault.id)
             .single();
 
            const anchorsSection = `\n\n## Visual Anchors & References\n\n${sanitizedAnchors.map((url: string) => `- [Reference](${url})`).join("\n")}`;
           
           await supabase
             .from("project_knowledge_vault")
             .update({
               project_charter: (existingCharter.data?.project_charter || "") + anchorsSection,
             })
             .eq("id", vault.id);
         }
       }
 
      // Get client email for confirmation
      const clientEmail = project.clients?.email;
      const filesCount = intakeToken.uploaded_files_count || 0;
      
      // Generate PDF Summary
      const pdfContent = generateIntakeSummaryPDF(
        clientName,
        project.title,
          sanitizedAnchors,
        filesCount
      );
      
      // Upload PDF to Drive
      const pdfBytes = new TextEncoder().encode(pdfContent);
      const pdfFile = await uploadFileToDrive(
        accessToken,
        folderId,
        `Intake_Summary_${new Date().toISOString().split('T')[0]}.pdf`,
        pdfBytes,
        'application/pdf'
      );
      
      if (pdfFile) {
        console.log('PDF Summary uploaded to Drive:', pdfFile.id);
      }
      
      // Send confirmation email if client email exists
      if (clientEmail) {
        await sendConfirmationEmail(accessToken, clientEmail, clientName, pdfContent);
      } else {
        console.log('No client email found, skipping confirmation email');
      }
      
      // Get staff user (Frankie) for task assignment
      const { data: staffUsers } = await supabase
        .from("user_roles")
        .select("user_id")
        .eq("role", "staff")
        .limit(1);
      
      const staffUserId = staffUsers?.[0]?.user_id;
      
      // Create task for Frankie: "Audit new client onboarding information"
      const nextMonday = new Date();
      const dayOfWeek = nextMonday.getDay();
      const daysUntilMonday = dayOfWeek === 0 ? 1 : (dayOfWeek === 1 ? 0 : 8 - dayOfWeek);
      nextMonday.setDate(nextMonday.getDate() + daysUntilMonday);
      
      await supabase.from("tasks").insert({
        project_id: project.id,
        title: "Audit new client onboarding information",
        description: `Review the intake submission from ${clientName}. Check the Knowledge Vault for Brand DNA and visual references.`,
        status: "todo",
        priority: "high",
        assigned_to: staffUserId,
        due_date: nextMonday.toISOString().split('T')[0],
        internal_notes: `Auto-generated from client intake submission. Files uploaded: ${filesCount}. Navigate to Knowledge Vault for details.`,
      });
      
      console.log('Audit task created for project:', project.id);

       // Create notification for admin/staff
       const { data: adminStaff } = await supabase
         .from("user_roles")
         .select("user_id")
         .in("role", ["admin", "staff"]);
 
       if (adminStaff && adminStaff.length > 0) {
         const notifications = adminStaff.map((role: { user_id: string }) => ({
           user_id: role.user_id,
           type: "intake_complete",
           title: "Onboarding Complete",
          message: `${clientName} has uploaded ${filesCount} asset${filesCount !== 1 ? "s" : ""}.`,
           data: { 
             project_id: project.id, 
             client_name: clientName,
            files_count: filesCount,
             navigate_to: "knowledge_vault"
           },
         }));
 
         await supabase.from("notifications").insert(notifications);
       }
 
       console.log(`Intake completed for project ${project.id}`);
 
       return new Response(
         JSON.stringify({
           success: true,
           message: "Onboarding completed successfully",
         }),
         { headers: { ...corsHeaders, "Content-Type": "application/json" } }
       );
     }
 
     return new Response(
       JSON.stringify({ error: "Invalid action" }),
       { status: 400, headers: { ...corsHeaders, "Content-Type": "application/json" } }
     );
 
   } catch (error) {
     console.error("Client intake error:", error);
     return new Response(
       JSON.stringify({ error: error instanceof Error ? error.message : "Unknown error" }),
       { status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" } }
     );
   }
 });